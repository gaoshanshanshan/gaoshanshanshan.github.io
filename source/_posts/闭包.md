---
title: 闭包
date: 2018-11-17 11:31:56
tags:
categories:
  - JavaScript 
---

# 闭包

---

闭包的形成与变量的作用域及变量的生存周期密切相关，在了解闭包之前，我们有必要先了解下这两个概念。

## 变量的作用域
> 变量的作用域，就是指变量的有效范围。作用域分为全局作用域和局部作用域（函数内部)，es6新增了块级作用域。块级作用域的概念这里就不再赘述，可以参考阮一峰老师的    [ECMAScript入门](http://es6.ruanyifeng.com/#docs/let)


当声明一个变量的时候，在非严格模式下，如果该变量前面没有带上var关键字，这个变量就会变为全局变量，这当然是一种容易造成变量冲突的做法。

另外一种是使用了var关键字在函数内生命的变量，此时的变量就是局部变量，只有在函数内部可以访问该变量，在函数外访问不到。

```
var func = function(){
    var a = 1;
    alert(a); // 输出 1
}

func();

alert(a) // 输出 Uncaught ReferenceError: a is not defined

```

## 变量的生存周期

对于全局变量来说，全剧变量的生存周期是永久的，除非我们主动销毁这个变量。
而对于函数内的局部变量来说，当函数执行完，局部变量就会随着函数的调用结束而被销毁：

```
var func = function(){
    var a = 1; //func函数执行完毕后变量a被销毁
    alert(a); 
}

func();
 

```

我们再来看下面这段代码：

```
var func = function(){
    var a = 1;
    return function(){
         a++; 
         alert(a); 
    }
}

var fn = func();

fn(); // 输出 2
fn(); // 输出 3
fn(); // 输出 4

```
跟我们预想的是否不一致，当退出函数func后，变量a并没有消失。这是因为执行var fn = func(),fn变量指向了一个匿名函数，而这个匿名函数可以访问到func()函数的执行环境，变量a就在这个环境中。变量a所在的环境被外界的fn访问，所以变量a就没有被销毁。这里就是一个闭包的结构。

## 闭包的更多作用

 1. 封装变量
    闭包可以帮我们把一些不需要暴漏在全局中的变量私有化。假设有一个缓存对象，用来缓存计算乘积的结果。
    ```
        var fn = (function(){
            var cache = {};
            return function(){
                var args = Array.prototype.join.call(arguments,',');
                if(args in cache){
                    return cache[args]
                }

                var a = 1;
                for(var i=0,l=arguments.length;i<l;i++){
                    a *= arguments[i];
                }

                return cache[args] = a;
            }
        })();ß

    ```
    这里我们将cache对象私有化，外界中不需要知道cache的存在，只需要调用fn函数就可以实现乘积的计算；

 2. 延续局部变量的生存周期
        
    在变量的生存周期小节中我们已经解释过了。下面在看一段代码

    ```
    var report = (function(){
        var imgs = {};
        return function(src){
            var img = new Image();
            imgs[src] = img;
            img.onerror = function(){ delete imgs.src }
            img.src = src;
        }
    })();

    ```
    img对象经常用于数据上报，但是在一些低版本浏览器中，img对象创建后，随着函数的调用结束会被销毁，此时可能还没有发出http请求。现在我们把img变量用闭包封装起来，就解决了这个问题。

## 闭包与内存管理
 
 局部变量本应该是在函数退出的时候被销毁的，如果局部变量在闭包中，那这个变量就能一直生存下去。所以当我们不再使用这些变量时，需要手动把这些变量设为null，以节省内存空间。